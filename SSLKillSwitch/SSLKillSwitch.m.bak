//
//  SSLKillSwitch.m
//  SSLKillSwitch
//
//  Created by Alban Diquet on 7/10/15.
//  Copyright (c) 2015 Alban Diquet. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <Security/SecureTransport.h>

#if SUBSTRATE_BUILD
#import "substrate.h"

#define PREFERENCE_FILE @"/private/var/mobile/Library/Preferences/com.nablac0d3.SSLKillSwitchSettings.plist"
#define PREFERENCE_KEY @"shouldDisableCertificateValidation"

#else

// #import "fishhook.h"
#import <dlfcn.h>

#endif


#pragma mark Utility Functions

static void SSKLog(NSString *format, ...)
{
   NSString *newFormat = [[NSString alloc] initWithFormat:@"=== SSLKill: %@", format];
   va_list args;
   va_start(args, format);
   NSLogv(newFormat, args);
   va_end(args);
}


#if SUBSTRATE_BUILD
// Utility function to read the Tweak's preferences
static BOOL shouldHookFromPreference(NSString *preferenceSetting)
{
   BOOL shouldHook = NO;
   NSMutableDictionary* plist = [[NSMutableDictionary alloc] initWithContentsOfFile:PREFERENCE_FILE];

   if (!plist)
   {
       SSKLog(@"Preference file not found.");
   }
   else
   {
       shouldHook = [[plist objectForKey:preferenceSetting] boolValue];
       SSKLog(@"Preference set to %d.", shouldHook);

       // Checking if BundleId has been excluded by user
       NSString *bundleId = [[NSBundle mainBundle] bundleIdentifier];
       bundleId = [bundleId stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];

       NSString *excludedBundleIdsString = [plist objectForKey:@"excludedBundleIds"];
       excludedBundleIdsString = [excludedBundleIdsString stringByReplacingOccurrencesOfString:@" " withString:@""];

       NSArray *excludedBundleIds = [excludedBundleIdsString componentsSeparatedByString:@","];

       if ([excludedBundleIds containsObject:bundleId])
       {
           SSKLog(@"Not hooking excluded bundle: %@", bundleId);
           shouldHook = NO;
       }
   }
   return shouldHook;
}
#endif


// Everyone's favorite OpenSSL constant
#define SSL_VERIFY_NONE 0

// Constant defined in BoringSSL
enum ssl_verify_result_t {
    ssl_verify_ok = 0,
    ssl_verify_invalid,
    ssl_verify_retry,
};


char *replaced_SSL_get_psk_identity(void *ssl)
{
    return "notarealPSKidentity";
}

// static void(*original_SSL_read)(SSL *ssl, void *buf, int num);
// int *replaced_SSL_read(SSL *ssl, void *buf, int num)
// {
//     SSKLog(@"Entering replaced_SSL_read()");
//     return original_SSL_read(SSL *ssl, void *buf, int num);
// }

static int custom_verify_callback_that_does_not_validate(void *ssl, uint8_t *out_alert)
{
    return ssl_verify_ok;
}

static void (*original_SSL_set_custom_verify)(void *ssl, int mode, int (*callback)(void *ssl, uint8_t *out_alert));
static void replaced_SSL_set_custom_verify(void *ssl, int mode, int (*callback)(void *ssl, uint8_t *out_alert))
{
    SSKLog(@"Entering replaced_SSL_set_custom_verify()");
    original_SSL_set_custom_verify(ssl, SSL_VERIFY_NONE, custom_verify_callback_that_does_not_validate);
    return;
}

__attribute__((constructor)) static void init(int argc, const char **argv)
{
    SSKLog(@"killssl int.");

    // Substrate-based hooking; only hook if the preference file says so
    if (shouldHookFromPreference(PREFERENCE_KEY))
    {
        SSKLog(@"Substrate hook enabled.");
           
        void* boringssl_handle = dlopen("/usr/lib/libboringssl.dylib", RTLD_NOW);
        SSKLog(@"Hooking SSL_set_custom_verify()...");
        void *SSL_set_custom_verify = dlsym(boringssl_handle, "SSL_set_custom_verify");
        MSHookFunction((void *) SSL_set_custom_verify, (void *) replaced_SSL_set_custom_verify,  (void **) &original_SSL_set_custom_verify);

        void *SSL_get_psk_identity = dlsym(boringssl_handle, "SSL_get_psk_identity");
        SSKLog(@"Hooking SSL_get_psk_identity()...");
        MSHookFunction((void *) SSL_get_psk_identity, (void *) replaced_SSL_get_psk_identity,  (void **) NULL);        

        // void *SSL_read = dlsym(boringssl_handle, "SSL_read");
        // SSKLog(@"Hooking SSL_read()...");
        // MSHookFunction((void *) SSL_read, (void *) replaced_SSL_read,  (void **)&original_SSL_read);

    }
    else
    {
        SSKLog(@"Substrate hook disabled.");
    }
}
